# Clean Architecture Layers

## Introduction to Clean Architecture

Clean Architecture is a software design philosophy that separates the elements of a design into ring levels. The main rule of Clean Architecture is that code dependencies can only move from the outer levels inward. Code on the inner levels can have no knowledge of functions on the outer levels.

## The Four Main Layers

Clean Architecture consists of four main layers:

1.  **Entities**: These are the core business objects of the application. They encapsulate the most general and high-level rules. They are the least likely to change when something external changes.
2.  **Use Cases (Interactors)**: This layer contains application-specific business rules. It orchestrates the flow of data to and from the Entities, and directs those Entities to use their enterprise-wide business rules to achieve the goals of the use case.
3.  **Interface Adapters**: This layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency such as the Database or the Web. This layer will wholly contain the MVC architecture of a GUI, for example.
4.  **Frameworks & Drivers**: This layer is generally composed of frameworks and tools such as the Database, the Web Framework, etc. This layer is where all the details go. The Web is a detail. The database is a detail. We keep these things on the outside where they can do little harm.

## The Dependency Rule

The concentric circles represent different areas of software. In general, the further in you go, the higher level the software becomes. The outer circles are mechanisms. The inner circles are policies.

The overriding rule that makes this architecture work is **The Dependency Rule**. This rule states that *source code dependencies can only point inwards*. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in an inner circle. That includes functions, classes, variables, or any other named software entity.

By the same token, data formats used in an outer circle should not be used by an inner circle, especially if those formats are generated by a framework in an outer circle. We donâ€™t want anything in an outer circle to impact the inner circles.

## Mapping Application Components to Clean Architecture Layers

This section maps the existing application components to the Clean Architecture layers.

### Entities

Entities represent the core business objects of the application. In the context of the `bq_meta_api` application, entities are defined by the Pydantic models in `bq_meta_api/models.py`. These models (e.g., `Table`, `Dataset`, `Routine`, `TableReference`, `Column`) encapsulate the structure and validation rules for the metadata objects retrieved from BigQuery. They are independent of any specific framework or database technology.

### Use Cases (Interactors)

Use Cases contain application-specific business rules and orchestrate the flow of data. The core application logic that would become use cases includes:

*   **`FetchBigQueryTableMetadata`**: Retrieves detailed metadata for a specific BigQuery table.
*   **`FetchBigQueryRoutineMetadata`**: Retrieves detailed metadata for a specific BigQuery routine.
*   **`ListDatasets`**: Lists all datasets available in a project.
*   **`ListTablesInDataset`**: Lists all tables within a specific dataset.
*   **`ListRoutinesInDataset`**: Lists all routines within a specific dataset.
*   **`SearchMetadata`**: Searches for metadata across datasets, tables, and routines based on a query.

The current modules contributing to these use cases are:

*   `logic.py`: Contains the primary orchestration logic for fetching and processing metadata. It would be refactored into specific use case classes.
*   `bigquery_client.py`: Provides the raw data from BigQuery, which is then processed by use cases.
*   `cache_manager.py`: Handles caching of data, which use cases would interact with to improve performance.
*   `search_engine.py`: Provides search functionality, which the `SearchMetadata` use case would utilize.
*   `main.py`: Currently, some FastAPI endpoint handlers contain logic that should be moved into use cases.

### Interface Adapters

Interface adapters convert data between the format suitable for use cases/entities and the format suitable for external agencies (like web frameworks or databases).

*   **Controllers/Presenters**:
    *   **Controllers**: The FastAPI path operation functions in `main.py` act as controllers. They receive HTTP requests and delegate to use cases. Examples:
        *   `GET /projects/{project_id}/datasets`
        *   `GET /projects/{project_id}/datasets/{dataset_id}/tables`
        *   `GET /projects/{project_id}/datasets/{dataset_id}/tables/{table_id}`
        *   `GET /projects/{project_id}/datasets/{dataset_id}/routines`
        *   `GET /projects/{project_id}/datasets/{dataset_id}/routines/{routine_id}`
        *   `GET /search`
    *   **Presenters**: Data transformation logic, currently found in `converter.py` and parts of `logic.py`, would be formalized as presenters. They would format the output of use cases (Entities or simple data structures) into HTTP responses (e.g., Pydantic models defined for API responses).

*   **Gateways (Repositories)**:
    Gateways are interfaces that define how data is retrieved or stored, abstracting the underlying data sources.
    *   **`BigQueryMetadataRepository` (Interface)**: Defines methods for fetching metadata from BigQuery (e.g., `get_table(table_id)`, `list_tables(dataset_id)`).
        *   *Implementation*: `bigquery_client.py` would be refactored to implement this interface.
    *   **`CacheRepository` (Interface)**: Defines methods for cache operations (e.g., `get(key)`, `set(key, value)`).
        *   *Implementation*: `cache_manager.py` would be refactored to implement this interface.
    *   **`SearchRepository` (Interface)**: Defines methods for interacting with the search index (e.g., `search_documents(query)`, `add_document(document)`).
        *   *Implementation*: `search_engine.py` would be refactored to implement this interface.

### Frameworks & Drivers (External Interfaces & DB)

This layer contains external frameworks, tools, and specific implementations for external interfaces.

*   **FastAPI (`main.py`)**: The web framework used to expose the API endpoints.
*   **Google BigQuery Client Library (`bigquery_client.py`)**: The driver used to interact with Google BigQuery.
*   **Cache Mechanism (`cache_manager.py`)**: The specific implementation of caching (e.g., in-memory, Redis).
*   **Configuration Management (`config.py`)**: Handles application configuration.
*   **Search Engine Library (`search_engine.py`)**: The specific search engine implementation (e.g., Whoosh).
*   **Pydantic (`models.py`, `main.py`)**: Used for data validation and serialization, acting as a data interchange format with the outside world (HTTP requests/responses).

These components are details that the inner layers (Entities, Use Cases) are independent of.

## Illustrating Data Flow: "Searching Metadata" Use Case

This section illustrates the data flow for the "Searching Metadata" use case, showing how the different layers interact.

1.  **Frameworks & Drivers (FastAPI & User)**:
    *   The user sends an HTTP GET request to the `/search` endpoint (e.g., `/search?query=customer&project_id=my_project`).
    *   FastAPI (Framework) receives the request. It validates the query parameters (`query`, `project_id`, `limit`, `offset`) against the Pydantic models defined for the endpoint (e.g., `SearchRequestModel`).

2.  **Interface Adapters (Controller)**:
    *   FastAPI routes the validated request and its data (e.g., `SearchRequestModel` instance) to the corresponding controller function (e.g., `search_metadata_controller` in `main.py` after refactoring).
    *   The controller extracts the necessary data from the `SearchRequestModel` (e.g., search query string, project ID).

3.  **Use Cases (Interactor - `SearchMetadataUseCase`)**:
    *   The controller calls the `execute` method of the `SearchMetadataUseCase`, passing the search query and project ID as simple data types (e.g., `str`, `int`).
    *   The `SearchMetadataUseCase` requires instances of `SearchRepository` and `CacheRepository` (injected via its constructor).

4.  **Interface Adapters (Repositories - `SearchRepository`, `CacheRepository`)**:
    *   **Cache Check (Optional but good practice)**: The `SearchMetadataUseCase` first calls the `CacheRepository`'s `get(cache_key)` method, where `cache_key` is generated from the search query and project ID.
        *   If the data is found in the cache, the `CacheRepository` (implemented by `cache_manager.py`) returns the cached data (likely a list of `SearchResultItem` Entities or plain dicts). The use case might then skip to step 6 or 7.
    *   **Search Execution**: If not cached or cache is stale, the `SearchMetadataUseCase` calls the `SearchRepository`'s `search_documents(query, project_id, ...)` method.
        *   The `SearchRepository` interface is implemented by `search_engine.py`. This implementation uses the specific search engine library (e.g., Whoosh) to query its index.
        *   The `SearchRepository` implementation might return a list of raw search results (e.g., dictionaries or simple objects specific to the search library).

5.  **Entities**:
    *   The `SearchRepository` implementation would be responsible for mapping the raw search results from the search engine library into a list of `SearchResultItem` Entities (or a similar domain-specific representation if `SearchResultItem` is deemed too application-specific). These Entities are defined in `models.py` (e.g., `SearchResultItem(name, type, project_id, dataset_id, description)`). This ensures the Use Case layer works with domain objects rather than infrastructure-specific data structures.

6.  **Use Cases (Interactor - `SearchMetadataUseCase` cont.)**:
    *   The `SearchMetadataUseCase` receives the list of `SearchResultItem` Entities from the `SearchRepository`.
    *   It performs any additional business logic, such as filtering, combining results, or applying access control (though access control might also be a separate, cross-cutting concern).
    *   If data was retrieved from the `SearchRepository` (and not cache), the use case might call `CacheRepository`'s `set(cache_key, search_results)` to store the results for future requests.
    *   The `SearchMetadataUseCase` returns a data structure containing the search results, typically a list of `SearchResultItem` Entities, to the controller. This is often a simple data transfer object (DTO) or a list of Entities.

7.  **Interface Adapters (Presenter)**:
    *   The controller receives the list of `SearchResultItem` Entities (or a DTO) from the `SearchMetadataUseCase`.
    *   The controller passes this data to a Presenter (e.g., `SearchPresenter`).
    *   The Presenter is responsible for formatting the `SearchResultItem` Entities into the `SearchResponseModel` (a Pydantic model defined for the API response, potentially in `main.py` or a dedicated `response_models.py`). This might involve selecting specific fields, restructuring data, or adding pagination metadata.

8.  **Frameworks & Drivers (FastAPI)**:
    *   The Presenter returns the `SearchResponseModel` instance to the controller.
    *   The controller returns this `SearchResponseModel` instance.
    *   FastAPI automatically serializes the Pydantic `SearchResponseModel` into a JSON HTTP response and sends it back to the user.

**Data Objects Passed:**

*   **HTTP Request -> Controller**: `SearchRequestModel` (Pydantic model, specific to FastAPI endpoint).
*   **Controller -> Use Case**: Simple data types (e.g., `query: str`, `project_id: str`).
*   **Use Case <-> Repository**:
    *   To `SearchRepository`: Search parameters (e.g., `query: str`, `project_id: str`).
    *   From `SearchRepository`: List of `SearchResultItem` Entities (defined in `models.py`).
    *   To/From `CacheRepository`: Cache key (`str`), cached data (list of `SearchResultItem` Entities or dicts).
*   **Use Case -> Presenter/Controller**: List of `SearchResultItem` Entities or a DTO containing them.
*   **Presenter -> Controller / FastAPI**: `SearchResponseModel` (Pydantic model, specific to API response).
*   **FastAPI -> HTTP Response**: JSON representation of `SearchResponseModel`.

This flow ensures that dependencies point inwards: Controllers depend on Use Cases, Use Cases depend on Repository Interfaces (not implementations) and Entities. Frameworks & Drivers are on the outermost layer, and Entities are at the core, with no dependencies on outer layers.

## Proposing Refactoring Steps (High-Level)

To align the `bq_meta_api` application with Clean Architecture, the following high-level refactoring steps are proposed. The primary goal is to **establish clear boundaries between layers** and ensure the Dependency Rule is respected.

1.  **Define Core Domain (Entities & Use Case Interfaces)**:
    *   **Entities**: Review `models.py`. While Pydantic models can serve as Entities, ensure they don't have direct dependencies on web frameworks or other infrastructure concerns. If they do, consider them as Data Transfer Objects (DTOs) for the outer layers and define pure Python objects as core Entities. For this application, Pydantic models are likely acceptable as Entities if they only contain data and validation logic, not framework-specific behavior.
    *   **Use Case Interfaces (Abstract Ports)**: Define abstract base classes or interfaces for each use case (e.g., `ISearchMetadataUseCase`, `IFetchTableDetailsUseCase`). These will reside in the domain layer.

2.  **Implement Application Logic (Use Case Implementations)**:
    *   Create concrete implementations for each use case interface (e.g., `SearchMetadataUseCaseImpl`). These implementations will contain the core application logic currently found in `logic.py` and parts of `main.py`.
    *   Use cases will depend on Repository Interfaces for data access.

3.  **Introduce Repository Interfaces (Abstract Ports for Data Access)**:
    *   Define repository interfaces for abstracting data access and external services. These are crucial for decoupling use cases from concrete implementations.
        *   `IBigQueryRepository`: For BigQuery metadata access.
        *   `ICacheRepository`: For caching mechanisms.
        *   `ISearchRepository`: For search engine interactions.
    *   These interfaces will be part of the use case layer or a dedicated "ports" sub-module within the domain.

4.  **Refactor Infrastructure Layer (Concrete Implementations of Repositories & External Services)**:
    *   Move existing `bigquery_client.py`, `cache_manager.py`, and `search_engine.py` to an `infrastructure` layer.
    *   Refactor these modules to implement the corresponding repository interfaces. For example, `BigQueryClient` in `bigquery_client.py` would implement `IBigQueryRepository`.
    *   This layer will also contain framework-specific configurations and drivers.

5.  **Separate Interface Adapters (Controllers, Presenters, Gateway Implementations)**:
    *   **Controllers**: Ensure FastAPI path operation functions in `main.py` are lean. They should primarily:
        *   Parse and validate incoming requests (FastAPI handles much of this with Pydantic).
        *   Call the appropriate use case with simple input data.
        *   Pass the use case output to a Presenter.
    *   **Presenters**: Formalize data transformation for responses. Presenters will take data from use cases (Entities or DTOs) and map it to HTTP response models (Pydantic models for API responses). `converter.py` logic would be integrated here.
    *   **Gateway Implementations**: The refactored `bigquery_client.py`, `cache_manager.py`, etc., serve as gateway implementations, but their definitions (interfaces) are used by the Use Cases.

6.  **Organize Directory Structure**:
    A potential new directory structure to reflect Clean Architecture could be:

    ```
    bq_meta_api/
    â”œâ”€â”€ domain/                   # Core business logic, independent of frameworks
    â”‚   â”œâ”€â”€ entities.py           # Core entity definitions (could be models.py if Pydantic models are pure)
    â”‚   â”œâ”€â”€ use_cases/            # Application-specific business rules
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ interfaces.py     # Abstract interfaces for use cases
    â”‚   â”‚   â””â”€â”€ search_metadata_use_case.py # Example use case
    â”‚   â””â”€â”€ repositories/         # Abstract interfaces for data access (ports)
    â”‚       â”œâ”€â”€ __init__.py
    â”‚       â”œâ”€â”€ bigquery_repository.py
    â”‚       â””â”€â”€ cache_repository.py
    â”‚       â””â”€â”€ search_repository.py
    â”‚
    â”œâ”€â”€ application/              # Use case implementations (orchestration)
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ services/             # Concrete implementations of use case interfaces
    â”‚   â”‚   â””â”€â”€ search_service.py # Example: SearchMetadataUseCaseImpl
    â”‚   â””â”€â”€ dto.py                # Data Transfer Objects used by use cases (if needed)
    â”‚
    â”œâ”€â”€ infrastructure/           # Frameworks, drivers, external tools
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ bigquery/             # BigQuery client implementation
    â”‚   â”‚   â””â”€â”€ client.py         # Implements IBigQueryRepository
    â”‚   â”œâ”€â”€ cache/                # Cache implementation
    â”‚   â”‚   â””â”€â”€ redis_cache.py    # Implements ICacheRepository
    â”‚   â”œâ”€â”€ search/               # Search engine implementation
    â”‚   â”‚   â””â”€â”€ whoosh_search.py  # Implements ISearchRepository
    â”‚   â””â”€â”€ config.py             # Application configuration
    â”‚
    â”œâ”€â”€ interfaces/               # Adapters to the outside world (API, CLI, etc.)
    â”‚   â”œâ”€â”€ api/                  # Web API related components
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ main.py           # FastAPI app setup, dependency injection
    â”‚   â”‚   â”œâ”€â”€ controllers/      # FastAPI path operation functions
    â”‚   â”‚   â”‚   â””â”€â”€ search_controller.py
    â”‚   â”‚   â”œâ”€â”€ presenters.py     # Data formatting for responses
    â”‚   â”‚   â””â”€â”€ request_models.py # Pydantic models for requests
    â”‚   â”‚   â””â”€â”€ response_models.py # Pydantic models for responses
    â”‚   â””â”€â”€ cli/                  # Command-line interface (if any)
    â”‚
    â””â”€â”€ models.py                 # Existing Pydantic models (evaluate if they belong in domain/entities.py or interfaces/api/)
    ```
    *Note: The existing `models.py` might be split or moved. If Pydantic models are pure data structures with validation, they can be `domain/entities.py`. If they include framework-specific features or are primarily for request/response shaping, parts might live in `interfaces/api/request_models.py` and `interfaces/api/response_models.py`.*

7.  **Dependency Injection**:
    *   Implement dependency injection to provide concrete implementations (from `infrastructure` and `application/services`) to components that depend on interfaces (e.g., controllers getting use case implementations, use cases getting repository implementations). FastAPI's dependency injection system can be leveraged for this.

This refactoring aims to create a more modular, testable, and maintainable application by adhering to the principles of Clean Architecture. Each step should be approached iteratively, with testing at each stage.

## Benefits of Applying Clean Architecture

Adopting Clean Architecture for the `bq_meta_api` application offers several significant advantages:

*   **Testability**: The core business logic (Use Cases) and Entities can be tested in isolation without needing the web framework (FastAPI), database (BigQuery client), or other external services. This makes unit tests simpler, faster, and more reliable. Mocking dependencies defined by interfaces becomes straightforward.

*   **Maintainability**: With a clear separation of concerns, the codebase becomes easier to understand, navigate, and debug. Changes in one layer (e.g., upgrading the FastAPI version) are less likely to impact other layers, reducing the risk of unintended side effects.

*   **Framework Independence**: The core application (Entities and Use Cases) is not tied to specific frameworks (like FastAPI), data storage solutions (BigQuery), or UI. This provides flexibility to upgrade these external components or even replace them with alternatives in the future with minimal impact on the core business logic.

*   **Scalability**: The modular design allows different parts of the application to be developed, deployed, and scaled independently. For instance, if a particular use case becomes a bottleneck, it can be optimized or scaled without affecting other parts of the system.

*   **Reusability**: Core business logic encapsulated in Use Cases can be potentially reused across different interfaces or applications. For example, the same search use case could be exposed via a REST API, a GraphQL API, or a command-line interface with minimal changes to the use case itself.

By investing in this architectural refactoring, the `bq_meta_api` will become more robust, adaptable to future changes, and easier for the team to manage and extend over time.
